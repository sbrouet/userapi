package com.sbr.userapi.model;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.SequenceGenerator;
import javax.persistence.Table;
import javax.validation.constraints.Email;
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * Entity for mapping users to the database table "USER"
 * 
 * @author sbrouet
 *
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "USER")
public class User {

	/**
	 * User id. Ids are generated by a sequence generator based on a sequence which
	 * is required to exist inside database
	 */
	@Id
	@SequenceGenerator(name = "userIdSequenceGenerator", sequenceName = "SEQ_USER_ID", initialValue = 10, allocationSize = 1)
	@GeneratedValue(generator = "userIdSequenceGenerator")
	@NotNull(message = "id cannot be null")
	private Long id;

	@Column(name = "first_name", nullable = false, length = 100)
	@NotBlank(message = "firstName cannot be null or blank")
	@Size(min = 1, max = 100, message = "first_name must be between {min} and {max} characters long")
	private String firstName;

	@Column(name = "email", nullable = false, length = 50)
	@Email(message = "Email should be valid")
	@NotBlank(message = "email cannot be null or blank")
	@Size(min = 10, max = 50, message = "email must be between {min} and {max} characters long")
	private String email;

	@Column(name = "password", nullable = false, length = 50)
	@NotBlank(message = "password cannot be null or blank")
	@Size(min = 10, max = 50, message = "password must be between {min} and {max} characters long")
	private String password;

	/**
	 * Constructor with all fields set except id
	 * 
	 * @param firstName user's first name
	 * @param email     user's email
	 * @param password  user's password
	 */
	public User(final String firstName, final String email, final String password) {
		super();
		this.firstName = firstName;
		this.email = email;
		this.password = password;
	}

	/**
	 * Password is purposely changed to '***' characters to avoid exposing it
	 * 
	 * @see Object#toString()
	 */
	@Override
	public String toString() {
		StringBuilder builder = new StringBuilder();
		builder.append("User [id=").append(id).append(", firstName=").append(firstName).append(", email=").append(email)
				.append(", password=***]");
		return builder.toString();
	}

	/**
	 * This implementation both complies with the Java {@link Object#hashCode()}
	 * contract and the requirement for Hibernate that {@link Object#equals(Object)}
	 * and {@link Object#hashCode()} methods must behave consistently across all
	 * entity state transitions.<BR/>
	 * WARNING : do <strong>NOT use very large {@link java.util.Set Sets} of
	 * users</strong> as they all will end up into the same bucket which will lead
	 * to poor performance
	 * 
	 * @return {@inheritDoc}
	 */
	@Override
	public int hashCode() {
		return 13;
	}

	/**
	 * This implementation both complies with the Java {@link Object#equals(Object)}
	 * contract and the Hibernate entities equality semantics (when two entities
	 * represent the same database row, they are equal, otherwise they are not). It
	 * also complies with the requirement for Hibernate that
	 * {@link Object#equals(Object)} and {@link Object#hashCode()} methods must
	 * behave consistently across all entity state transitions.
	 * 
	 * @see https://access.redhat.com/documentation/en-us/jboss_enterprise_application_platform/4.3/html/hibernate_reference_guide/persistent_classes-implementing_equals_and_hashcode
	 * @see https://vladmihalcea.com/how-to-implement-equals-and-hashcode-using-the-jpa-entity-identifier/
	 * @param obj {@inheritDoc}
	 * @return {@inheritDoc}
	 * 
	 */
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (!(obj instanceof User)) {
			return false;
		}

		User other = (User) obj;

		// A transient entity cannot be equal to any other entity
		if (null == id) {
			return false;
		}

		// Entities are equal when they both represent same row in database, here having
		// same generated id
		return id.equals(other.getId());
	}

}